<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Newsletter Extract</title>
<style>
  body { font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif; line-height:1.6; background:#f4f4f4; color:#333; margin:0; padding:20px; }
  .container { max-width:900px; margin:0 auto; background:#fff; padding:25px 30px; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.08); }
  h1 { color:#d62021; text-align:center; margin:0 0 8px; }
  .sub { text-align:center; margin:0 0 18px; color:#555; }
  .row { display:flex; gap:10px; align-items:center; }
  input[type="url"] { width:100%; padding:12px; border:1px solid #ccc; border-radius:6px; font-size:16px; box-sizing:border-box; }
  button { padding:12px 14px; border:none; border-radius:6px; font-size:15px; font-weight:700; cursor:pointer; }
  #extract-btn { background:#3d79d8; color:#fff; }
  #extract-btn:disabled { background:#999; cursor:not-allowed; }
  #paste-btn { background:#111827; color:#fff; }
  #paste-btn:disabled { background:#999; cursor:not-allowed; }
  .hint { font-size:13px; color:#666; margin:10px 0 0; }
  .panel { margin-top:18px; border-top:1px solid #eee; padding-top:18px; }
  textarea.big { width:100%; min-height:140px; padding:12px; border:1px solid #ddd; border-radius:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; box-sizing:border-box; }
  #results { margin-top:18px; }
  .loader { border:5px solid #f3f3f3; border-top:5px solid #3d79d8; border-radius:50%; width:40px; height:40px; animation:spin 1s linear infinite; margin:14px auto; }
  @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }
  .error { color:#d62021; font-weight:800; }
  .warn { color:#92400e; font-weight:700; background:#fffbeb; border:1px solid #fde68a; padding:10px 12px; border-radius:8px; }
  .result-item { margin-bottom:14px; display:flex; gap:10px; align-items:stretch; }
  .result-item label { font-weight:800; color:#111; width:160px; padding-top:8px; flex:0 0 auto; }
  .result-item .content { flex:1; display:flex; gap:10px; align-items:center; }
  .result-item textarea.out { width:100%; padding:10px; border:1px solid #ddd; border-radius:8px; background:#f9f9f9; font-family:inherit; font-size:15px; box-sizing:border-box; resize:none; overflow:hidden; }
  .copy { background:#16a34a; color:#fff; white-space:nowrap; }
  .copy.copied { background:#6b7280; }
  .imgrow { display:flex; gap:14px; align-items:flex-start; }
  .preview { max-width:260px; border-radius:10px; border:1px solid #eee; }
  .foot { margin-top:18px; color:#555; text-align:center; }
  .small { font-size:12px; color:#6b7280; }
</style>
</head>
<body>
<div class="container">
  <h1>Newsletter Content Collector</h1>
  <p class="sub">Paste the link to the story below.</p>

  <div class="row">
    <input id="story-url" type="url" placeholder="https://www.npr.org/..." />
    <button id="extract-btn">Collect UPDATE!</button>
  </div>

  <div class="panel">

    <textarea id="html-paste" class="big" placeholder="Paste NPR page source here (View Page Source → Copy all)"></textarea>
    <div style="display:flex; gap:10px; margin-top:10px;">
      <button id="paste-btn">Extract from pasted HTML</button>
      <button id="clear-btn" style="background:#e5e7eb;">Clear</button>
    </div>
  </div>

  <div id="results"></div>

  <div class="foot">
    <div>Questions? +1 (707) 412-8684</div>
    <div class="small">❤️ Michal Ruprecht</div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const extractBtn = $("extract-btn");
  const pasteBtn = $("paste-btn");
  const clearBtn = $("clear-btn");
  const urlInput = $("story-url");
  const pasteBox = $("html-paste");
  const resultsDiv = $("results");

  // Public mirror that often bypasses CORS by returning the page as plain text.
  // Not guaranteed forever, but best you can do with "single HTML file, no backend".
  const MIRROR_PREFIX = "https://r.jina.ai/http://";
  const MIRROR_PREFIX_TLS = "https://r.jina.ai/https://";

  const escapeHtml = (s) => (s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));

  const decodeEntities = (s) => {
    if (!s) return "";
    const t = document.createElement("textarea");
    t.innerHTML = s;
    return t.value;
  };

  const autoResize = (ta) => { ta.style.height = "auto"; ta.style.height = (ta.scrollHeight + 2) + "px"; };

  const fetchTextWithTimeout = async (url, ms=15000) => {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), ms);
    try {
      const res = await fetch(url, { signal: controller.signal, cache:"no-store" });
      if (!res.ok) throw new Error(`Network response not ok (status ${res.status})`);
      return await res.text();
    } finally {
      clearTimeout(timer);
    }
  };

  // --- Extraction logic from raw HTML string ---
  function extractFromHtml(html, fallbackUrl="") {
    // Meta helpers
    const metaProp = (prop) => {
      const re = new RegExp(`<meta[^>]+property=["']${prop}["'][^>]+content=["']([^"']+)["']`, "i");
      const m = html.match(re);
      return m ? decodeEntities(m[1]).trim() : "";
    };
    const metaName = (name) => {
      const re = new RegExp(`<meta[^>]+name=["']${name}["'][^>]+content=["']([^"']+)["']`, "i");
      const m = html.match(re);
      return m ? decodeEntities(m[1]).trim() : "";
    };
    const linkRel = (rel) => {
      const re = new RegExp(`<link[^>]+rel=["']${rel}["'][^>]+href=["']([^"']+)["']`, "i");
      const m = html.match(re);
      return m ? decodeEntities(m[1]).trim() : "";
    };

    const headline = metaProp("og:title") || "Not Found";
    const link = linkRel("canonical") || metaProp("og:url") || fallbackUrl || "Not Found";
    const teaser = metaName("description") || metaProp("og:description") || "Not Found";
    const photo = metaProp("og:image") || "";

    // Authors: cXenseParse:author sometimes has multiple separated by |
    let authorsRaw = metaName("cXenseParse:author") || "";
    let authors = [];
    if (authorsRaw) {
      authors = authorsRaw.split("|").map(s => s.trim()).filter(Boolean);
    } else {
      // fallback: try to find "By" byline block in page source
      const byRe = /class=["'][^"']*\bbyline__name\b[^"']*["'][^>]*>\s*<a[^>]*>([^<]{2,120})<\/a>/ig;
      let m; const set = new Set();
      while ((m = byRe.exec(html)) !== null) set.add(decodeEntities(m[1]).trim());
      authors = Array.from(set);
    }

    // Photo credit: look for <span class="credit" aria-label="Image credit"> ... </span>
    let credit = "Not Found in source. Please copy manually.";
    const creditMatch = html.match(/<span[^>]+class=["'][^"']*\bcredit\b[^"']*["'][^>]+aria-label=["']Image credit["'][^>]*>([\s\S]*?)<\/span>/i);
    if (creditMatch) {
      const txt = decodeEntities(creditMatch[1])
        .replace(/<[^>]*>/g, " ")
        .replace(/\s+/g, " ")
        .trim();
      if (txt) credit = txt;
    }

    const authorStr = (arr) => {
      if (!arr || arr.length === 0) return "";
      if (arr.length === 1) return `${arr[0]} reports for NPR`;
      if (arr.length === 2) return `${arr[0]} and ${arr[1]} report for NPR`;
      return `${arr.slice(0,-1).join(", ")} and ${arr[arr.length-1]} report for NPR`;
    };

    const ensurePeriod = (s) => {
      s = (s || "").trim();
      if (!s) return s;
      return /[.!?]$/.test(s) ? s : (s + ".");
    };

    const teaserNoAuthor = teaser !== "Not Found" ? ensurePeriod(teaser) : "Not Found";
    const teaserWithAuthor = teaser !== "Not Found"
      ? ensurePeriod(authors.length ? `${teaser} ${authorStr(authors)}` : teaser)
      : (authors.length ? ensurePeriod(authorStr(authors)) : "Not Found");

    return {
      headline,
      link,
      photo,
      credit,
      teaser: teaserNoAuthor,
      teaser_with_author: teaserWithAuthor
    };
  }

  function renderResults(data) {
    const rows = [
      { label: "Headline", id: "headline", value: data.headline || "Not Found" },
      { label: "Link to story", id: "link", value: data.link || "Not Found" },
      { label: "Photo", id: "photo", value: data.photo || "" },
      { label: "Photo credit", id: "credit", value: data.credit || "Not Found" },
      { label: "Teaser", id: "teaser_no_author", value: data.teaser || "Not Found" },
      { label: "Teaser with author", id: "teaser", value: data.teaser_with_author || "Not Found" }
    ];

    const imgPreview = data.photo
      ? `<div class="imgrow"><img class="preview" src="${escapeHtml(data.photo)}" alt="photo preview"/></div>`
      : "";

    resultsDiv.innerHTML = `
      ${imgPreview}
      <div style="margin-top:${data.photo ? "12px" : "0"};"></div>
      ${rows.map(r => `
        <div class="result-item">
          <label for="${r.id}-out">${escapeHtml(r.label)}:</label>
          <div class="content">
            <textarea class="out" id="${r.id}-out" readonly>${r.value}</textarea>
            <button class="copy" data-target="${r.id}-out">Copy</button>
          </div>
        </div>
      `).join("")}
    `;

    rows.forEach(r => autoResize($(r.id + "-out")));
  }

  function setLoading(msg) {
    resultsDiv.innerHTML = `<div class="loader"></div><p style="text-align:center; color:#555;">${escapeHtml(msg)}</p>`;
  }

  function setError(msg) {
    resultsDiv.innerHTML = `<p class="error">Failed to fetch the story.</p><p class="small">${escapeHtml(msg)}</p>`;
  }

  async function extractFromUrl() {
    const nprUrl = urlInput.value.trim();
    if (!nprUrl.startsWith("https://www.npr.org/")) {
      setError('Please use a URL that starts with "https://www.npr.org/".');
      return;
    }

    extractBtn.disabled = true;
    pasteBtn.disabled = true;
    setLoading("Trying mirror fetch…");

    try {
      // Try mirror (most reliable without backend)
      const mirrorUrl = (nprUrl.startsWith("https://") ? (MIRROR_PREFIX_TLS + nprUrl.replace(/^https:\/\//, "")) : (MIRROR_PREFIX + nprUrl.replace(/^http:\/\//, "")));
      const html = await fetchTextWithTimeout(mirrorUrl, 15000);

      // jina.ai returns a text-wrapped response, but meta tags are still present in many cases.
      // If not, editors can paste page source.
      const data = extractFromHtml(html, nprUrl);
      renderResults(data);

      // If it looks empty, nudge the paste fallback
      if ((data.headline === "Not Found" && data.teaser === "Not Found") || html.length < 500) {
        resultsDiv.insertAdjacentHTML("afterbegin",
          `<div class="warn" style="margin-bottom:12px;">
             Mirror returned limited HTML for this page. Use the paste box fallback below for guaranteed extraction.
           </div>`
        );
      }

    } catch (err) {
      // This is where you were seeing "signal is aborted" — timeout/abort or blocked mirror.
      setError(String(err && err.message ? err.message : err) + "  •  Use the Paste HTML fallback below (guaranteed).");
    } finally {
      extractBtn.disabled = false;
      pasteBtn.disabled = false;
    }
  }

  function extractFromPaste() {
    const html = pasteBox.value;
    if (!html || html.length < 200) {
      setError("Paste the full NPR page source (View Page Source → copy all).");
      return;
    }
    const data = extractFromHtml(html, urlInput.value.trim());
    renderResults(data);
  }

  resultsDiv.addEventListener("click", async (e) => {
    const btn = e.target.closest("button.copy");
    if (!btn) return;
    const id = btn.dataset.target;
    const ta = $(id);
    if (!ta) return;
    try {
      await navigator.clipboard.writeText(ta.value);
      btn.textContent = "Copied!";
      btn.classList.add("copied");
      setTimeout(() => { btn.textContent = "Copy"; btn.classList.remove("copied"); }, 1200);
    } catch {
      alert("Copy failed (clipboard permission).");
    }
  });

  extractBtn.addEventListener("click", (e) => { e.preventDefault(); extractFromUrl(); });
  pasteBtn.addEventListener("click", (e) => { e.preventDefault(); extractFromPaste(); });
  clearBtn.addEventListener("click", (e) => {
    e.preventDefault();
    pasteBox.value = "";
    resultsDiv.innerHTML = "";
  });

  urlInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); extractFromUrl(); }
  });
})();
</script>
</body>
</html>
