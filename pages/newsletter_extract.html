<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>Newsletter Content Collector</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      background-color: #f4f4f4;
      color: #333;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: #fff;
      padding: 25px 30px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    h1 {
      color: #d62021;
      text-align: center;
      margin-bottom: 10px;
    }
    p { text-align: left; color: #555; }
    p#instructions {
      text-align: center;
      color: #555;
      margin-bottom: 25px;
    }
    #story-url {
      width: 100%;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 16px;
      box-sizing: border-box;
    }
    #extract-btn {
      display: block;
      width: 100%;
      padding: 12px;
      background-color: #3d79d8;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.3s;
    }
    #extract-btn:hover:not(:disabled) { background-color: #2a5aab; }
    #extract-btn:disabled { background-color: #999; cursor: not-allowed; }
    #results {
      margin-top: 30px;
      border-top: 2px solid #eee;
      padding-top: 20px;
      text-align: center;
    }
    .result-item {
      margin-bottom: 20px;
      display: flex;
      text-align: left;
      align-items: stretch;
      gap: 10px;
    }
    .result-item label {
      font-weight: bold;
      color: #444;
      flex-basis: 150px;
      flex-shrink: 0;
      padding-top: 8px;
    }
    .result-item .content-wrapper {
      flex-grow: 1;
      display: flex;
      align-items: center;
    }
    .result-item textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
      font-family: inherit;
      font-size: 15px;
      box-sizing: border-box;
      resize: none;
      overflow: hidden;
    }
    .result-item .copy-btn {
      padding: 8px 15px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-weight: bold;
      white-space: nowrap;
    }
    .result-item .copy-btn:hover { background-color: #218838; }
    .result-item .copy-btn.copied { background-color: #6c757d; }
    .error-message { color: #d62021; font-weight: bold; }
    .loader {
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3d79d8;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .small {
      font-size: 12px;
      color: #777;
      margin-top: 8px;
      line-height: 1.3;
      text-align: left;
    }
    code {
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 4px;
    }
  </style>
</head>

<body>
<div class="container">
  <h1>Newsletter Content Collector</h1>
  <p id="instructions">Paste the link to the story below.</p>

  <input id="story-url" placeholder="https://www.npr.org/..." type="url"/>
  <button id="extract-btn">Collect Content!</button>

  <div id="results"></div>

  <p>Questions? +1 (707) 412-8684
    <center>
      <br>Dig up the gold for your newsletter
      <br>❤️ Michal Ruprecht from the Science Desk
    </center>
  </p>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const extractBtn = document.getElementById('extract-btn');
  const urlInput = document.getElementById('story-url');
  const resultsDiv = document.getElementById('results');

  const decodeHtml = (htmlStr) => {
    const txt = document.createElement("textarea");
    txt.innerHTML = htmlStr;
    return txt.value;
  };

  const autoResizeTextarea = (textarea) => {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
  };

  // Fetch with a hard timeout so you don't spin forever
  const fetchWithTimeout = async (url, timeoutMs = 15000) => {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, { signal: controller.signal });
      return res;
    } finally {
      clearTimeout(t);
    }
  };

  // Multiple proxy fallbacks (because these services randomly block / rate-limit)
  const proxyCandidates = (nprUrl) => ([
    // Often works well for HTML fetch without CORS issues:
    `https://r.jina.ai/${nprUrl}`,

    // Your original (kept as fallback; commonly 403s now):
    `https://corsproxy.io/?${encodeURIComponent(nprUrl)}`,

    // Another common public proxy:
    `https://api.allorigins.win/raw?url=${encodeURIComponent(nprUrl)}`
  ]);

  const getHtmlViaProxies = async (nprUrl) => {
    let lastErr = null;

    for (const p of proxyCandidates(nprUrl)) {
      try {
        const res = await fetchWithTimeout(p, 15000);

        if (!res.ok) {
          lastErr = new Error(`Proxy failed: ${p} (status ${res.status})`);
          continue;
        }

        const text = await res.text();

        // crude sanity check: if we got some HTML-ish content, accept it
        if (text && text.length > 200) return text;

        lastErr = new Error(`Proxy returned empty content: ${p}`);
      } catch (e) {
        lastErr = e;
      }
    }

    throw lastErr || new Error("All proxy attempts failed.");
  };

  const doExtract = async () => {
    const nprUrl = urlInput.value.trim();

    if (!nprUrl.startsWith('https://www.npr.org')) {
      resultsDiv.innerHTML =
        '<p class="error-message">Please enter a valid URL starting with "https://www.npr.org"</p>';
      return;
    }

    extractBtn.disabled = true;
    extractBtn.dataset.orig = extractBtn.textContent;
    extractBtn.textContent = 'Fetching...';
    resultsDiv.innerHTML = '<div class="loader"></div><p>Getting story from NPR...</p>';

    try {
      const sourceCode = await getHtmlViaProxies(nprUrl);

      const parser = new DOMParser();
      const doc = parser.parseFromString(sourceCode, 'text/html');

      const headline =
        doc.querySelector('meta[property="og:title"]')?.getAttribute('content')?.trim() ||
        doc.querySelector('h1')?.textContent?.trim() ||
        'Not Found';

      const storyLink =
        doc.querySelector('link[rel="canonical"]')?.getAttribute('href') ||
        nprUrl;

      // Teaser/description
      const teaser =
        doc.querySelector('meta[name="description"]')?.getAttribute('content') ||
        doc.querySelector('meta[property="og:description"]')?.getAttribute('content') ||
        '';

      // Photo (prefer og:image; NPR page DOM changes a lot)
      let photo =
        doc.querySelector('meta[property="og:image"]')?.getAttribute('content') || '';

      if (photo) {
        photo = photo.replace(/\/resize\/\d+/, '/resize/600');
        photo = photo.replace(/\/quality\/\d+/, '/quality/85');
        photo = photo.replace(/\/format\/\w+/, '/format/png');
      }

      // Authors
      let authorsArray = [];
      const authorEls = doc.querySelectorAll(
        'p.byline__name.byline__name--block a[rel="author"], .byline__name.byline__name--block a[rel="author"]'
      );
      if (authorEls && authorEls.length > 0) {
        authorEls.forEach(el => {
          const name = el.textContent.trim();
          if (name) authorsArray.push(name);
        });
      } else {
        const metaAuthor = doc.querySelector('meta[name="cXenseParse:author"]')?.getAttribute('content');
        if (metaAuthor) {
          authorsArray = metaAuthor.split('|').map(a => a.trim()).filter(Boolean);
        }
      }

      // Photo credit: best-effort (this is the most brittle part)
      let photoCredit = 'Not Found in source. Please copy manually.';
      const storytextEl = doc.getElementById('storytext') || doc.querySelector('.storytext, article');
      if (storytextEl) {
        const creditEl = storytextEl.querySelector(
          '.credit[aria-label="Image credit"], b.credit[aria-label="Image credit"], span.credit[aria-label="Image credit"]'
        );
        if (creditEl?.textContent?.trim()) photoCredit = creditEl.textContent.trim();
      }

      // Teaser variants
      let teaserWithoutAuthor = "Not Found";
      if (teaser) {
        teaserWithoutAuthor = teaser.trim();
        if (!teaserWithoutAuthor.endsWith(".")) teaserWithoutAuthor += ".";
      }

      let teaserWithAuthor = "Not Found";
      if (teaser) {
        if (authorsArray.length > 0) {
          let authorStr = "";
          if (authorsArray.length === 1) authorStr = `${authorsArray[0]} reports for NPR`;
          else if (authorsArray.length === 2) authorStr = `${authorsArray[0]} and ${authorsArray[1]} report for NPR`;
          else authorStr = `${authorsArray.slice(0, -1).join(", ")} and ${authorsArray[authorsArray.length - 1]} report for NPR`;

          teaserWithAuthor = `${teaser.trim()} ${authorStr}`;
          if (!teaserWithAuthor.endsWith(".")) teaserWithAuthor += ".";
        } else {
          teaserWithAuthor = teaser.trim();
          if (!teaserWithAuthor.endsWith(".")) teaserWithAuthor += ".";
        }
      } else if (authorsArray.length > 0) {
        teaserWithAuthor = (authorsArray.length === 1)
          ? `${authorsArray[0]} reports for NPR.`
          : `${authorsArray.join(", ")} report for NPR.`;
      }

      const extractedData = [
        { label: 'Headline', id: 'headline', value: headline },
        { label: 'Link to story', id: 'link', value: storyLink },
        { label: 'Photo', id: 'photo', value: photo },
        { label: 'Photo credit', id: 'credit', value: photoCredit },
        { label: 'Teaser', id: 'teaser_no_author', value: teaserWithoutAuthor },
        { label: 'Teaser with author', id: 'teaser', value: teaserWithAuthor }
      ];

      resultsDiv.innerHTML = '';
      extractedData.forEach(item => {
        const cleanValue = item.value ? decodeHtml(item.value) : 'Not Found';
        const resultItem = document.createElement('div');
        resultItem.className = 'result-item';
        resultItem.innerHTML = `
          <label for="${item.id}-output">${item.label}:</label>
          <div class="content-wrapper">
            <textarea id="${item.id}-output" readonly>${cleanValue}</textarea>
          </div>
          <button class="copy-btn" data-target="${item.id}-output">Copy</button>
        `;
        resultsDiv.appendChild(resultItem);
        autoResizeTextarea(resultItem.querySelector('textarea'));
      });

      // show which proxy worked (quietly helpful for debugging)
      const note = document.createElement('div');
      note.className = 'small';
      note.innerHTML = `If this ever breaks again, it’s almost always a proxy block (403). This page tries multiple proxies now.`;
      resultsDiv.appendChild(note);

    } catch (error) {
      console.error('Fetch Error:', error);
      resultsDiv.innerHTML = `
        <p class="error-message">
          Failed to fetch the story.<br>
          <small>${(error && error.message) ? error.message : String(error)}</small>
        </p>
        <div class="small">
          What this means: the public proxy got blocked (403) or timed out. Public proxies are flaky by nature.
          The permanent fix is hosting your own tiny proxy (Cloudflare Worker / Netlify function).
        </div>
      `;
    } finally {
      extractBtn.disabled = false;
      extractBtn.textContent = extractBtn.dataset.orig || 'Collect Content!';
    }
  };

  extractBtn.addEventListener('click', (e) => { e.preventDefault(); doExtract(); });

  urlInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); doExtract(); }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); doExtract(); }
  });

  resultsDiv.addEventListener('click', (e) => {
    if (e.target.classList.contains('copy-btn')) {
      const button = e.target;
      const targetId = button.dataset.target;
      const textareaToCopy = document.getElementById(targetId);
      if (textareaToCopy && navigator.clipboard) {
        navigator.clipboard.writeText(textareaToCopy.value).then(() => {
          button.textContent = 'Copied!';
          button.classList.add('copied');
          setTimeout(() => {
            button.textContent = 'Copy';
            button.classList.remove('copied');
          }, 2000);
        }).catch(() => alert('Failed to copy text.'));
      } else {
        alert('Clipboard not available in this browser context.');
      }
    }
  });
});
</script>
</body>
</html>
